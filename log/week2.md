# Log Message for Major Project for Week 2
## What was your goal for the past week?

My goal for the past week was to create a working version of my tic-tac-toe game that would run without needing any additional modifications. To do this, I had to finish the rest of the computer opponent's decision-making ability, allow the player to make a move on the tic-tac-toe grid, and check whether someone had won. I completed the computer's AI by separating it's moves into four categories: 1. first turn moves, 2. special case moves, 3. win condition moves, and 4. other moves. I developed my program so that the computer opponent goes first, so that I could whether my code for determining what the computer should do was working or not. On the first turn, the computer, with equal probability, randomly chooses either the center tile (1,1) or an edge tile (0,0), (0,2), (2,0), or (2,2). For the special case moves, I learned, while researching this project, that if two players form an incomplete diagonal, it is a good move to complete that diagonal by filling in the missing space. To determine whether there was a win condition, I would assign a marker to the middle tile of the first row (0,1) and use a loop which ran through 3 iterations (0-3 exclusive). If the row was not the middle row (1,x), then I would only check whether the right and left tiles were similar to my marked tile or if they were similar to each other in the case that the middle tile was empty. Regardless of whether it was two of the human player's icons or the computer's icons, the computer would complete the row if one of the tiles was blank. For the middle row, the computer would check for the middle column, the row, both diagonals, and also the left and right columns using the method described above. If the computer had made a move in any of the previous stages, it would assign the value of true to a boolean which would prevent the computer from making multiple moves. If the computer found no moves it could make as there are no tiles within the same row, column, or diagonal of each other, then it would move on. In the last type of move the computer could make, it would use it's most recently placed icon and place another icon in an adjacent tile. The icon would be placed to the right in the instance of it being in the first or second row, however it would be placed to the left if the most recent tile is in the third row.

Since the computer opponent always went first, I put the code giving the human player a turn below the computer's AI. I first printed the grid so the player could see where the computer had placed it's icon, and prompted the player with where they would like to place their icon. First, I would check if the user's input was of length two. This is because I ask the user for input in the form of a letter followed by a number. The letter corresponds to the column, while the number corresponds to the row. Because the input is of type string, I don't need to check for InputMismatch. To convert the letters to numbers, I take the substring of the user's choice (0,1 exclusive) and convert it to uppercase. Then, I use a switch statement to decide whether the user's input for the first index of their substring matches the letters 'A', 'B', or 'C'. If not, a message is printed to the screen explaining what the inputs must be and starting the loop asking for input from the beginning. Finally, I check whether the tile the user wants to place their icon on is occupied. If the tile is occupied, a message would be printed to the screen telling the player they would need to choose another tile. Otherwise, if the tile is empty, that tile is assigned the player's icon, and the human player's turn ends.

To check whether someone had won, I had to check in two different places in my code during each turn. The first place is after the computer's turn ends. If the computer has three of their icons in a row, whether in a row, column, or diagonal, then they win. Otherwise, they don't win. The next place I had to check is after the player's turn ends. The same rules apply to the player as to the computer opponent on whether they won. If I did not place the code after each player's turn, then it would be possible for both players to win, or for the player who won second to have been declared the winner.

## Did you accomplish last weekâ€™s goal? Why/why not?

I did not fully accomplish this week's goal. Currently, the program runs and has the specifications that I described above, however I'm experiencing two issues right now. First, the computer player makes several moves after the first turn, which I will have to debug using print statements to determine which code is running when it's not supposed to. Second, I did not finish checking if either player had won as I was trying to debug my code. However, I think the hardest part of the project is now complete, which was designing an algorithm for determining what the computer should do in response to the player's actions. Debugging may or may not take a long time, however I will be doing this on my own time before the end of week 3.

## What did you learn this week?

I learned how to deconstruct the problem of checking whether a condition has been met into several short and simple if-statements. This is how I solved the problem of having the computer check if there were any win condition moves. I also learned about the limitation of this type of coding. While my code may run and it may be effective and efficient, I do not particularly like how it's written. It's not elegant and it would require extensive reworking to function in different settings, such as larger size grids, the option for the human player to go first, and possibly some strange actions on the tic-tac-toe grid that I did not account for. This isn't to say that my code is bad or has any problems, but I still think I can improve on it.

## What is your goal for next week?

My goal for next week is to have a completed project as it's the last week and also the date of the presentation. I need to have have fixed the bugs described above, as well as finished coding a system for checking whether either player has won after each of their turns. Additionally, I would like to improve my code so that the limitations described above no longer exist in my code. This, however, might be asking too much. I'll have to experiment and see whether it's reasonably within my current ability or whether it's too time-consuming, labour-intensive, and/or outside of the scope of my knowledge.

## What are the main challenges you are facing next week?

The main challenges I'll be facing next week are having clean, efficient, code that is bug-free. It's usually easy to account for things you can think of, but it's a different case to account for things you didn't think of. But that's kind of obvious. I anticipated this project to be fairly easy, but it turns out there's still a lot I don't know, and without instructions outlining what you should do and how to go about it, it's hard to gauge how much progress you're actually making. I say this because I'm not sure how much more I can improve on this project, though I would like to. I think that will be the main challenge I'll have to face next week.

## Additional Information (Self-created heading)

This is the article I used for my research on how to never lose at tic-tac-toe: https://www.quora.com/Is-there-a-way-to-never-lose-at-Tic-Tac-Toe?share=1. I also used this image as reference as to some of the possible beginning combinations in tic-tac-toe: https://upload.wikimedia.org/wikipedia/commons/1/1f/Tic-tac-toe-full-game-tree-x-rational.jpg. 

- The tic-tac-toe grid I use in my game is actually a 2-dimensional string aray of size [3,3].
- The human player is given the option to select their icon before the game begins. This choice uses a try-catch to prevent InputMismatch as the variables are of type char. Entering an invalid input results in a default icon of 'x' being assigned.
- The grid is created using underscores for empty grid spaces, 'X' or 'O' for occupied spaces, and pipes to to separate the icons. This is done by taking the empty int array representing the grid and replacing all the zeros with underscores. Above the printed grid, numbers represent the columns, while on the left side of the printed grid, the letters 'A', 'B', and 'C' represent the rows.
